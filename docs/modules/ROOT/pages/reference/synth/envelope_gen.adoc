= Envelope Generator

include::../../common.adoc[]

== Overview

image::envelope_gen.svg[alt="Envelope Generator", width=1000]

`envelope_gen` is a highly configurable multi-segment envelope generator. Each segment is a `{ramp}` that can be configured to have any conceivable shape. A few ramp shapes, including exponential, linear, blackman, and hann are provided. The user may add their own `{ramp}` generator following a well defined c++ concept specification.

The plot above is an example of a 5-segment envelope generator output. The ramp segments S1 to S5 are as follows:

1. `blackman_upward_ramp_gen` (see {blackman_gen})
2. `hold_line_gen` (see {linear_gen})
3. `blackman_downward_ramp_gen` (see {blackman_gen})
4. `lin_downward_ramp_gen` (see {linear_gen})
5. `exp_downward_ramp_gen` (see {exponential_gen})

== Phases and Transitions

There are four phases of interest:

1. Idle phase: Waiting for the next attack signal Ⓐ, the output sits at zero.
2. Attack phase: Initiated when the attack signal Ⓐ is received, e.g. when the key is pressed.
3. Intermediate phase: Starts after the attack phase and before the release phase.
4. Release phase: Initiated when the release signal Ⓡ is received, e.g when the key is released.

The graph below depicts the phases and transitions of the multi-segment envelope generator.

image::envelope_gen_seq.svg[alt="Phases and Transitions", width=500]

The envelope generator waits for an attack signal Ⓐ while in the idle phase. As soon as an attack signal Ⓐ is received, the state immediately transitions to the attack phase. The output ramps up from 0.0 to the specified attack level, over the specified attack duration.

The envelope generator is not retriggerable. Another attack signal Ⓐ may only occur while in the idle phase. Any attack signal Ⓐ received while not in the idle phase is ignored.

TIP: Use one envelope generator instance per note. This is most natural with polyphonic voicing, but can also apply to monophonic voicing. For monophonic voicing, on an incoming attack signal Ⓐ, active envelope generators are sent release signals Ⓡ, a new envelope generator is created, and its attack phase is initiated. The output will then be the maximum of all active envelope generators.

After the attack phase, anything that comes in between the attack phase and release phase are intermmediate phases that are sequenced by the multi-segment envelope generator, one after the other. Intermmediate phases may include the decay phase, the hold phase and the sustain phase. For each intermediate phase, the output ramps up or down from the previous level to the phase's level over the phase's duration.

Upon receiving the release signal Ⓡ, the envelope generator immediately transitions to the release phase. This may occur at any point during the attack or intermediate phases. The current phase may be cut short when this happens, and without delay, the output ramps down to 0.0 over the specified release duration.

After the completion of the release phase, the envelope generator returns back to the idle state.

== Envelope Segment

Each envelope segment has parameters for width (the duration of the segment), level (the end level of the segment), and of course the `{ramp}` type. A `make_envelope_segment` free function, templated on the ramp type, is provided for making segments.

=== Declaration

```c++
struct envelope_segment
{
                        envelope_segment(envelope_segment const&);
    envelope_segment&   operator=(envelope_segment const&);

    /*** Unspecified member functions ***/
};

template <typename T>
inline envelope_segment make_envelope_segment(duration width, float level, float sps);
```

=== Expressions

==== Notation

`s`, `a`, `b`   :: Objects of type `envelope_segment`.
`w`             :: Object of type `duration`.
`l`             :: Floating point value representing level (0.0 to 1.0).
`sps`           :: Floating point value representing samples per second.
`T`             :: `{ramp}` type.

==== Constructors and Assignment

[cols="1,1"]
|===
| Expression            | Semantics

| `envelope_segment(s)` | Copy construct from `s`.
| `a = b`               | Assign `b` to `a`.
|===

==== Factory

[cols="1,1,1"]
|===
| Expression                    | Semantics                     | Return Type

a|
```c++
make_envelope_segment<T>(
    w, l, sps)
```
                                | Make an envelope segment with
                                  specified `{ramp}` type, `T`,
                                  level, `l`, width, `w`, and
                                  samples per second, `sps`.
                                                                | `envelope_segment`
|===

==== Example

```c++
// Make a 10 ms exponential segment with a peak level of 1.0.
auto s = make_envelope_segment<exp_upward_ramp_gen>(10_ms, 1.0f, sps);
```

== Envelope Generator

The envelope generator is basically a container (std::vector) of envelope segments. Multiple segments with distinct shape characteristics may be used to construct ADSR envelopes, AD envelopes, etc.

=== Declaration

```c++
struct envelope_gen : std::vector<envelope_segment>
{
   using base_type = std::vector<envelope_segment>;

   using base_type::base_type;

   void           attack();
   void           release();
   float          operator()();
   float          current() const;
   void           reset();

   bool           is_idle() const;
   bool           attack_phase() const;
   bool           release_phase() const;
};
```

As a subclass of `std::vector<envelope_segment>`, you can use all the facilities of `std::vector` to compose a multi-segment envelope generator of varying complexity.

=== Expressions

`envelope_gen` is a subclass of `std::vector<envelope_segment>`. In addition to valid expressions for https://en.cppreference.com/w/cpp/container/vector[`std::vector], `envelope_gen` allows these expressions.

==== Notation

`g`      :: Object of type `envelope_gen`.

==== Function Call

[cols="1,1,1"]
|===
| Expression         | Semantics                      | Return Type

| `g()`              | Generate the next value.       | `float`
|===

==== Operation

[cols="1,1"]
|===
| Expression         | Semantics

| `g.attack()`       | Start the attack phase.
| `g.release()`      | Start the release phase.
| `g.reset()`        | Reset and move to the idle phase.
|===

==== Accessors

[cols="1,1,1"]
|===
| Expression         | Semantics                      | Return Type

| `g.current()`      | Get the current level.         | `float`
|===



NOTE: WORK IN PROGRESS!

