= decibel

include::../../common.adoc[]

:db-amplitude: image:db-amplitude-graph.png[alt="440Hz Phase Increments", width=450, role=right]

{db-amplitude}The decibel (dB) is a unit used to measure the relative signal level difference between two signals. It is a logarithmic scale that expresses the relationship between two signal root-power amplitudes or power levels. Here, we are concerned with amplitudes.

For amplitudes gain, the relationship is given by:

```
20 log10(out/in) = dB
```

where `out` represents the output amplitude, while in represents the `input` amplitude.

The decibel scale is expressed as the base 10 logarithm of the ratio between two amplitudes. For instance, a ratio of 2:1 (two times) corresponds to a 6 dB increase, while a ratio of 10:1 (ten times) corresponds to a 20 dB increase. In contrast, a ratio of 1:2 (one half) corresponds to a -6 dB decrease, whereas a ratio of 1:10 (one tenth) corresponds to a -20 dB decrease.

Decibel is non-linear and operates on the logarithmic domain. The `decibel` class is perfectly suitable for dynamics processing (e.g. compressors and limiters and envelopes). Q provides fast `decibel` computations using fast math functions and lookup tables for converting to and from scalars.

== Include

```c++
#include <q/support/decibel.hpp>
```

== Declaration

```c++
struct decibel
{
   struct _direct {};
   constexpr static _direct direct = {};

   constexpr            decibel();
   explicit             decibel(double val);
   constexpr            decibel(double val, _direct);

   constexpr decibel    operator+() const;
   constexpr decibel    operator-() const;

   constexpr decibel&   operator+=(decibel b);
   constexpr decibel&   operator+=(concepts::arithmetic_scalar auto b);

   constexpr decibel&   operator-=(decibel b);
   constexpr decibel&   operator-=(concepts::arithmetic_scalar auto b);

   constexpr decibel&   operator*=(concepts::arithmetic_scalar auto b);
   constexpr decibel&   operator/=(concepts::arithmetic_scalar auto b);

   double rep = 0.0f;
};

////////////////////////////////////////////////////////////////////////////
// Free functions
////////////////////////////////////////////////////////////////////////////
double               as_double(decibel db);
constexpr float      as_float(decibel db);

constexpr decibel    operator+(decibel a, decibel b);
constexpr decibel    operator+(decibel a, concepts::arithmetic_scalar auto b);
constexpr decibel    operator+(concepts::arithmetic_scalar auto a, decibel b);

constexpr decibel    operator-(decibel a, decibel b);
constexpr decibel    operator-(decibel a, concepts::arithmetic_scalar auto b);
constexpr decibel    operator-(concepts::arithmetic_scalar auto a, decibel b);

constexpr decibel    operator*(decibel a, concepts::arithmetic_scalar auto b);
constexpr decibel    operator*(concepts::arithmetic_scalar auto a, decibel b);

constexpr double     operator/(decibel a, decibel b);
constexpr decibel    operator/(decibel a, concepts::arithmetic_scalar auto b);

constexpr bool       operator==(decibel a, decibel b);
constexpr bool       operator!=(decibel a, decibel b);
constexpr bool       operator<(decibel a, decibel b);
constexpr bool       operator<=(decibel a, decibel b);
constexpr bool       operator>(decibel a, decibel b);
constexpr bool       operator>=(decibel a, decibel b);
```

Everywhere in this reference documentation, the term _scalar_ refers to unitless arithmetic scalar types. This concept is captured in this C++ concept declaration:

```c++
namespace cycfi::q::concepts
{
   template <typename T>
   concept arithmetic_scalar = std::integral<T> || std::floating_point<T>;
}
```

== Expressions

In addition to valid expressions for {Value}, `decibel` allows these expressions.

=== Notation

`a`, `b`, `d`  :: Object of type `decibel`
`v`            :: Scalar value.

==== Constructor

The main decibel constructor from a scalar value (i.e. `decibel(v)`) performs linear to decibel conversion. If you do not wish to perform this conversion and store the decibel value directly in the underlying scalar representation, you can use the direct constructor below.

[cols="1,1"]
|===
| Expression                     |  Semantics

| `decibel(v, decibel::direct)`  |  Direct construction of underlying value (no conversion).
|===

If you need to create `decibel` from numeric literals, it is preferrable to use `decibel` literals instead. Example:

```c++
auto db = -6_dB;
```

NOTE: C++ brace initialization may also be used.

=== Conversions

[cols="1,1,1"]
|===
| Expression      | Semantics                               | Return Type

| `as_float(d)`   | Convert `decibel` to a scalar.          | `float`
| `as_double(d)`  | Convert `decibel` to a scalar.          | `double`
|===

