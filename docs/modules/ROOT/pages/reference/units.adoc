= Units

== Overview

image:decibel.png[alt="dB Image courtesy of Wikipedia", float="right"] The Q DSP library processes audio signals by applying various audio processors to sample inputs. These processors typically operate with floating-point input samples in the typical -1.0 to 1.0 range. However, the values are not restricted to sampled signals. For instance, signal envelopes are best represented as decibels processed in the logarithmic domain. Consequently, dynamic-range processors such as compressors and expanders accept decibel as input and return decibel as output.

The Q DSP library is typeful and typesafe, which means that each data type is explicitly defined and enforced. This is crucial because it avoids the potentially catastrophic errors that could result from mismatching values of different types. For example, if all values were just raw floating point types, it would be possible to accidentally mix up the frequency and decibel values. Mistakenly interchanging frequency and decibel values could result in erroneous processing of the audio signal and will lead to undefined results.

This document aims to provide comprehensive documentation of the fundamental data types used by the Q DSP library. These basic units are utilized consistently throughout the library and serve as the basis for quantifying specific parameters, such as decibels (dB) for signal level and hertz (Hz) for frequency.

== Value

"Value" is a conceptual representation of a linear numerical quantity.

=== Expressions

==== Notation

[cols="1,1"]
|===
|Symbol | Description

| `V`          | Value type

| `v`          | Scalar value.

| `a`, `b`     | Instances of `Value`.

|===


==== Constructors and assignment

[cols="1,1"]
|===
| Expression   |  Semantics

| `V{}`        |  Empty brace initialization. Value initialize a `Value`

| `V()`        |  Default construction.

| `V\{v}`      |  Brace initialization from scalar value `v`.

| `V(v)`       |  Construct a `Value` from scalar value `v`.

| `V\{a}`      |  Copy brace initialization from `Value a`.

| `V(a)`       |  Copy construct from `Value a`.

| `a = b`      |  Assignment. Assign `Value b`, to `Value a`.

|===


==== Comparison

[cols="1,1,1"]
|===
| Expression   | Semantics                                     | Return Type

| `a == b`     | Equality.                                     | `bool`

| `a == v`     | Equality with a scalar.                       | `bool`

| `v == b`     | Equality with a scalar.                       | `bool`

| `a != b`     | Non-Equality.                                 | `bool`

| `a != v`     | Non-Equality with a scalar.                   | `bool`

| `v != b`     | Non-Equality with a scalar.                   | `bool`

| `a < b`      | Less than.                                    | `bool`

| `a < v`      | Less than with a scalar.                      | `bool`

| `v < b`      | Less than with a scalar.                      | `bool`

| `a \<= b`    | Less than equal.                              | `bool`

| `a \<= v`    | Less than equal with a scalar.                | `bool`

| `v \<= b`    | Less than equal with a scalar.                | `bool`

| `a > b`      | Greater than.                                 | `bool`

| `a > v`      | Greater than with a scalar.                   | `bool`

| `v > b`      | Greater than with a scalar.                   | `bool`

| `a >= b`     | Greater than equal.                           | `bool`

| `a >= v`     | Greater than equal with a scalar.             | `bool`

| `v >= b`     | Greater than equal with a scalar.             | `bool`

|===

==== Arithmetic

[cols="1,1,1"]
|===
| Expression   | Semantics                                     | Return Type

| `+a`         | Positive.                                     | `Value`

| `-a`         | Negative.                                     | `Value`

| `a += b`     | Add assign.                                   | `Value&`

| `a -= b`     | Subtract assign.                              | `Value&`

| `a *= b`     | Multiply assign.                              | `Value&`

| `a /= b`     | Divide assign.                                | `Value&`

| `a + b`      | Addition.                                     | `Value`

| `a + v`      | Addition with a scalar.                       | `Value`

| `v + b`      | Addition with a scalar.                       | `Value`

| `a - b`      | Subtraction.                                  | `Value`

| `a - v`      | Subtraction with a scalar.                    | `Value`

| `v - b`      | Subtraction with a scalar.                    | `Value`

| `a * b`      | Multiplication.                               | `Value`

| `a * v`      | Multiplication with a scalar.                 | `Value`


| `v * b`      | Multiplication with a scalar.                 | `Value`

| `a / b`      | Division.                                     | `Value`

| `a / v`      | Division with a scalar.                       | `Value`

| `v / b`      | Division with a scalar.                       | `Value`

|===

== Value Models

=== frequency

Type safe representation of frequency in Hertz.

==== Include

```c++
#include <q/support/frequency.hpp>
```

==== Declaration

```c++
struct frequency : _unspecified_base_type_
{
   constexpr explicit   frequency(double val);
   constexpr q::period  period() const;
};

// Free functions
constexpr double  as_double(frequency f);
constexpr float   as_float(frequency f);
```

==== Expressions

In addition to valid expressions for `Value`, `frequency` allows these
expressions.

==== Notation

[cols="1,1"]
|===
| Symbol    |  Description

| `f`          | Instance of `frequency`.

|===

==== Construction

[cols="1,1"]
|===
| Expression      |  Semantics

| `frequency\{f}` |  Brace initialize a `frequency` given a scalar value, `f`.

| `frequency\(f)` |  Construct a `frequency` given a scalar value, `f`.

|===


==== Conversions

[cols="1,1,1"]
|===
| Expression   | Semantics                                     | Return Type

| `as_float(f)`   | Convert frequency to a scalar.             | `float`

| `as_double(f)`  | Convert frequency to a scalar.             | `double`

|===


==== Misc

[cols="1,1,1"]
|===
| Expression   | Semantics                                     | Return Type

| `f.period()`    | Get the period (1/f).                      | `period`        |

|===

=== duration

Type safe representation of duration.

==== Include

```c++
#include <q/support/duration.hpp>
```

==== Declaration

```c++
struct duration : _unspecified_base_type_
{
   constexpr   duration(double val);
};

// Free functions
constexpr double  as_double(duration d);
constexpr float   as_float(duration d);
```

==== Expressions

In addition to valid expressions for Value, `duration` allows these
expressions.

==== Notation

[cols="1,1"]
|===
| Symbol    |  Description

| `d`       | Instance of `duration`

|===

==== Conversions

[cols="1,1"]
|===
| Expression      |  Semantics

| `as_float(d)`   |  Convert duration to a scalar (float)

| `as_double(d)`  |  Convert duration to a scalar (double)

|===

=== period

Type safe representation of period (reciprocal of frequency).

==== Include

```c++
#include <q/support/period.hpp>
```

==== Declaration

```c++
struct period : duration
{
   using duration::duration;

   constexpr   period(duration d);
   constexpr   period(frequency f);
};
```

==== Expressions

In addition to valid expressions for Value, `period` allows these
expressions.

==== Notation

[cols="1,1"]
|===
| Symbol    |  Description

| `d`       | Instance of `duration`

| `f`       | Instance of `frequency`

| `p`       | Instance of `period`

|===

==== Construction

[cols="1,1"]
|===
| Expression   | Semantics

| `phase\{d}`  | Brace initialize a `period` from a duration, `d`

| `phase\(d)`  | Construct a `period` given a duration, `d`

| `phase\{f}`  | Brace initialize a `period` from a frequency, `f`

| `phase\(f)`  | Construct a `period` given a frequency, `f`

|===

==== Conversions

[cols="1,1,1"]
|===
| Expression   | Semantics                                     | Return Type

| `as_float(f)`   | Convert frequency to a scalar.             | `float`

| `as_double(f)`  | Convert frequency to a scalar.             | `double`

|===

=== phase

`phase` represents phase values that run from 0 to 2π suitable for oscillators. `phase` is represented as fixed point 1.31 format where 31 bits are fractional.

The turn, also cycle, full circle, revolution, and rotation, is a complete circular movement or measure (as to return to the same point) with circle or ellipse. A turn is abbreviated τ, cyc, rev, or rot depending on the application. The symbol τ can also be used as a mathematical constant to represent 2π radians.

https://en.wikipedia.org/wiki/Angular_unit[https://en.wikipedia.org/wiki/Angular_unit]

==== Include

```c++
#include <q/support/phase.hpp>
```

==== Declaration

```c++
struct phase : _unspecified_base_type_
{
   constexpr explicit            phase(value_type val = 0);
   constexpr explicit            phase(float frac);
   constexpr explicit            phase(double frac);
   constexpr explicit            phase(long double frac);
   constexpr                     phase(frequency freq, float sps);

   constexpr static phase        begin();
   constexpr static phase        end();
   constexpr static phase        middle();
};

// Free functions
constexpr double  as_double(phase d);
constexpr float   as_float(phase d);
```

==== Expressions

In addition to valid expressions for Value, `phase` allows these
expressions.

==== Notation

[cols="1,1"]
|===
| Symbol       | Description

| `f`          | A `double` or `float`

| `freq`       | Instance of `frequency`

| `sps`        | Scalar value representing samples per second

| `p`          | Instance of `phase`

|===

==== Construction

[cols="1,1"]
|===
| Expression         | Semantics

| `phase\{f}`        | Brace initialize a phase given a fractional number from 0.0 to 1.0 (0 to 2π)

| `phase(f)`         | Construct a phase given a fractional number from 0.0 to 1.0 (0 to 2π)


| `phase{freq, sps}` | Brace initialize a phase given the frequency and samples per second (`sps`)

| `phase(freq, sps)` | Construct a phase given the frequency and samples per second (`sps`)


|===

==== Conversions

[cols="1,1,1"]
|===
| Expression      | Semantics                                  | Return Type

| `as_float(p)`   | Convert phase to a scalar from 0.0 to 1.0. | `float`

| `as_double(p)`  | Convert phase to a scala from 0.0 to 1.0r. | `double`

|===

==== Min and Max

[cols="1,1,1"]
|===
| Expression      | Semantics                                           | Return Type

| phase::begin()  | Get the minimum phase representing 0 degrees        | `phase`

| phase::end()    | Get the maximum phase representing 360 degrees (2π) | `phase`

| phase::middle() | Get the phase representing 180 degrees (π)          | `phase`

|===


=== Intervals

An interval is the distance between two pitches, measured in semitones. It is the basis for melody and harmony as well as all musical scales and chords. The `basic_interval<T>` is a template class, parameterized by the underlying type `T`.

==== Include

```c++
#include <q/support/pitch.hpp>
```

==== Declaration

```c++
template <typename T>
struct basic_interval : _unspecified_base_type_
{
   constexpr explicit   basic_interval(T val);
};

// Free functions
template <typename T>
constexpr int as_int(basic_interval<T> i);

template <typename T>
constexpr float as_float(basic_interval<T> i);

template <typename T>
constexpr double as_double(basic_interval<T> i);
```

There are two basic type instantiations: `interval` and `exact_interval`.

`interval`:: Fractional interval. Can represent microtones —intervals smaller than a semitone.
`exact_interval`:: Deals with exact, whole number intervals only.

```c++
using interval = basic_interval<double>;
using exact_interval = basic_interval<std::int8_t>;
```

==== Expressions

In addition to valid expressions for `Value`, `basic_interval<T>` allows these
expressions.

==== Notation

[cols="1,1"]
|===
| Symbol       |  Description

| `i`          | Instance of `basic_interval<T>`.

|===

==== Conversions

[cols="1,1,1"]
|===
| Expression      | Semantics                                  | Return Type

| `as_int(i)`     | Convert an interval to a scalar.           | `int`

| `as_float(i)`   | Convert an interval to a scalar.           | `float`

| `as_double(i)`  | Convert an interval to a scalar.           | `double`

|===


== NonLinearValue

A representation of a non-linear scalar value as a concept. Unlike linear values, `NonLinearValue`, by default, does not permit arithmetic operations, although certain models of `NonLinearValue` may permit restricted arithmetic operations as necessary. Comparison operators are allowed.

=== Expressions

==== Notation

[cols="1,1"]
|===
|Symbol        | Description

| `V`          | NonLinearValue type

| `v`          | Scalar value.

| `a`, `b`     | Instance of `NonLinearValue`

|===

==== Constructors and assignment

[cols="1,1"]
|===
| Expression   |  Semantics

| `V{}`        |  Empty brace initialization. Value initialize a `Value`.

| `V()`        |  Default construction.

| `V\{v}`      |  Brace initialization from scalar value `v`.

| `V(v)`       |  Construct a `Value` from scalar value `v`.

| `V\{a}`      |  Copy brace initialization from `Value a`.

| `V(a)`       |  Copy construct from `Value a`.

| `a = b`      |  Assignment. Assign `Value b`, to `Value a`.

|===

==== Comparison

[cols="1,1,1"]
|===
| Expression   | Semantics                                     | Return Type
| `a == b`     | Equality.                                     | `bool`

| `a != b`     | Non-Equality.                                 | `bool`

| `a < b`      | Less than.                                    | `bool`

| `a \<= b`     | Less than equal.                             | `bool`

| `a > b`      | Greater than.                                 | `bool`

| `a >= b`     | Greater than equal.                           | `bool`

|===

== NonLinearValue Models

=== decibel

Decibel is non-linear and operates on the logarithmic domain. The `decibel` class is perfectly suitable for dynamics processing (e.g. compressors and limiters and envelopes). Q provides fast `decibel` computations using fast math functions and lookup tables for converting to and from scalars.

==== Include

```c++
#include <q/support/decibel.hpp>
```

==== Declaration

```c++
struct decibel
{
   constexpr            decibel();
   explicit             decibel(double val);

   constexpr decibel    operator+() const;
   constexpr decibel    operator-() const;

   constexpr decibel&   operator+=(decibel b);
   constexpr decibel&   operator-=(decibel b);
   constexpr decibel&   operator*=(decibel b);
   constexpr decibel&   operator/=(decibel b);

   double rep = 0.0f;
};

// Free functions
constexpr double  as_double(decibel db);
constexpr float   as_float(decibel db);

constexpr decibel operator-(decibel a, decibel b);
constexpr decibel operator+(decibel a, decibel b);

constexpr decibel operator*(decibel a, decibel b);
constexpr decibel operator*(decibel a, double b);
constexpr decibel operator*(decibel a, float b);
constexpr decibel operator*(decibel a, int b);
constexpr decibel operator*(double a, decibel b);
constexpr decibel operator*(float a, decibel b);
constexpr decibel operator*(int a, decibel b);

constexpr decibel operator/(decibel a, decibel b);
constexpr decibel operator/(decibel a, double b);
constexpr decibel operator/(decibel a, float b);
constexpr decibel operator/(decibel a, int b);

constexpr bool    operator==(decibel a, decibel b);
constexpr bool    operator!=(decibel a, decibel b);
constexpr bool    operator<(decibel a, decibel b);
constexpr bool    operator<=(decibel a, decibel b);
constexpr bool    operator>(decibel a, decibel b);
constexpr bool    operator>=(decibel a, decibel b);
```

==== Expressions

In addition to valid expressions for `NonLinearValue`, `decibel` allows these expressions.

==== Notation

[cols="1,1"]
|===
| Symbol          |  Description

| `a`, `b`, `d`   | Instance of `decibel`

| `v`             | Scalar value.

|===

==== Arithmetic

`decibel` extends `NonLinearValue` and has a complete set of arithmetic operations with `decibel` operands, and a restricted set of arithmetic operations with mixed `decibel` and bare scalars only for multiplication and division.

[cols="1,1,1"]
|===
| Expression   | Semantics                                     | Return Type

| `+a`         | Positive.                                     | `decibel`

| `-a`         | Negative.                                     | `decibel`

| `a += b`     | Add assign.                                   | `decibel&`

| `a -= b`     | Subtract assign.                              | `decibel&`

| `a *= b`     | Multiply assign.                              | `decibel&`

| `a /= b`     | Divide assign.                                | `decibel&`

| `a + b`      | Addition.                                     | `decibel`

| `a - b`      | Subtraction.                                  | `decibel`

| `a * b`      | Multiplication.                               | `decibel`

| `a / b`      | Division.                                     | `decibel`

| `a * v`      | Multiplication with a scalar.                 | `decibel`

| `v * b`      | Multiplication with a scalar.                 | `decibel`

| `a / v`      | Division with a scalar.                       | `decibel`

|===

==== Conversions

[cols="1,1,1"]
|===
| Expression      | Semantics                               | Return Type

| `as_float(d)`   | Convert `decibel` to a scalar.          | `float`

| `as_double(d)`  | Convert `decibel` to a scalar.          | `double`

|===

=== pitch

`pitch` is determined by its position on the chromatic scale, which is a system of 12 notes that repeat in octaves. The distance between each pitch on the chromatic scale is a semitone, and each pitch represents a specific frequency measured in hertz (Hz).

The `pitch` struct includes construction from `frequency` as well as scalars representing the absolute position in the chromatic scale from the base frequency of `8.1757989156437` Hz, which is an octave below F#0. The constructors support both fixed (integer) positions (e.g. 48 semitones) above the base frequency, and fractional positions (e.g. 120.6 semitones) above the base frequency.

The `pitch` struct also includes conversions to `frequency`. Q provides fast `pitch` computations using fast math functions.

==== Include

```c++
#include <q/support/pitch.hpp>
```

==== Declaration

```c++
struct pitch
{
   constexpr static auto base_frequency = frequency{8.1757989156437};

   constexpr            pitch();
   explicit             pitch(frequency f);
   constexpr            pitch(int val);
   constexpr            pitch(float val);
   constexpr            pitch(double val);

   constexpr explicit   operator bool() const;
   constexpr bool       valid() const;

                        template <typename T>
   constexpr pitch&     operator+=(basic_interval<T> b);

                        template <typename T>
   constexpr pitch&     operator-=(basic_interval<T> b);

   double rep = 0.0f;
};

// Free functions
frequency  as_frequency(pitch n);
float      as_float(pitch n);
double     as_double(pitch n);

template <typename T>
constexpr pitch    operator-(pitch a, basic_interval<T> b);

template <typename T>
constexpr pitch    operator+(basic_interval<T> a, pitch b);

template <typename T>
constexpr pitch    operator+(pitch a, basic_interval<T> b);

constexpr bool    operator==(pitch a, pitch b);
constexpr bool    operator!=(pitch a, pitch b);
constexpr bool    operator<(pitch a, pitch b);
constexpr bool    operator<=(pitch a, pitch b);
constexpr bool    operator>(pitch a, pitch b);
constexpr bool    operator>=(pitch a, pitch b);

constexpr pitch    round(pitch n);
constexpr pitch    ceil(pitch n);
constexpr pitch    floor(pitch n);
```

==== Expressions

In addition to valid expressions for `NonLinearValue`, `decibel` allows these expressions.

==== Notation

[cols="1,1"]
|===
| Symbol       |  Description

| `p`          | Instance of `pitch`

| `i`          | Instance of `basic_interval<T>`.

|===

==== Arithmetic

`pitch` extends `NonLinearValue` and allows a very restricted set of arithmetic operations with `pitch` and `basic_interval<T>` operands (see <<Intervals>>).

[cols="1,1,1"]
|===
| Expression   | Semantics                                     | Return Type

| `p += i`     | Add assign.                                   | `pitch&`

| `p -= i`     | Subtract assign.                              | `pitch&`

| `i + p`      | Addition.                                     | `pitch`

| `p + i`      | Addition.                                     | `pitch`

| `p - i`      | Subtraction.                                  | `pitch`

|===

==== Conversions

[cols="1,1,1"]
|===
| Expression         | Semantics                               | Return Type

| `as_float(p)`      | Convert `pitch` to a scalar.            | `float`

| `as_double(p)`     | Convert `pitch` to a scalar.           | `double`

| `as_frequency(p)`  | Convert `pitch` to a `frequency`.       | `frequency`

|===

==== Functions

[cols="1,1,1"]
|===
| Expression         | Semantics                               | Return Type

| `round(p)`         | Rounds a `pitch` to the nearest
                       non-fractional `pitch`.                 | `pitch`

| `ceil(p)`          | Returns the smallest non-fractional
                       `pitch` that is greater than or equal
                       to a given `pitch`                      | `pitch`

| `floor(p)`         | Returns the largest non-fractional
                       `pitch` that is less than or equal
                       to a given `pitch`                      | `pitch`

|===





